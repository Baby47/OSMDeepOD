\section{Benutzerhandbuch}
\subsection{Suche der Fussgängerstreifen}
Um die Suche der Fussgängerstreifen durchzuführen muss eine Redis Datenbank zur Verfügung stehen , weiter muss auf den Rechnern die als Jobworker tätig sind Docker installiert sein. \\
Die Installationen sind in folgenden Abschnitten aufgeführt:
\begin{itemize}
	\item Redis:  Abschnitt~\ref{subsec:redis} auf der Seite~\pageref{subsec:redis}
	\item Docker: Abschnitt~\ref{subsec:docker} auf der Seite~\pageref{subsec:docker}
\end{itemize}

\subsubsection{Einführung}
Wir haben unsere Applikation in drei Rollen aufgeteilt:
\begin{itemize}
	\item Manager
	\begin{itemize}
		\item Unterteilt eine grosse Boundingbox in Kleinere mit einer Höhe und Breite von jeweils 2 Kilometern und stellt dies als Jobs in die Queue.
	\end{itemize}
	\item Jobworker
	\begin{itemize}
		\item Arbeite die Jobs der Queue ab
		\item Gefundene Fussgängerstreifen , welche noch nicht in OpenSteetMap erfasst sind, werden als "Resultat Job" in die Queue gestellt
	\end{itemize}
	\item Resultworker
	\begin{itemize}
		\item Schlussendlich werden die Resultate zusammen getragen und in ein JSON File geschrieben
	\end{itemize}
\end{itemize}

Dieser Ablauf ist genauer beschrieben unter dem Abschnitt~\ref{subsec:ablauf} auf der Seite~\pageref{subsec:ablauf}

\newpage
\subsubsection{Anwendung}
Dank Docker kann unsere Applikation innert Minuten gestartet werden.

\paragraph{Docker Pull}
\begin{lstlisting}[style=BashInputStyle]
	# docker pull murthy10/osm-crosswalk-detection
\end{lstlisting}

\paragraph{Manager}
\begin{lstlisting}[style=BashInputStyle]
 # docker run murthy10/osm-crosswalk-detection REDIS_IP_ADDR 
 --role manager left bottom right top
\end{lstlisting}
Left, Bottom, Right, Top entsprechen den Koordinaten im WGS84 Format. \\
Ostschweiz: left=8.361002, bottom=47.166994, right=8.977610, top=47.706676) 

\paragraph{Jobworker}
\begin{lstlisting}[style=BashInputStyle]
 # docker run murthy10/osm-crosswalk-detection REDIS_IP_ADDR 
 --role jobworker
\end{lstlisting}
Jobworker können auf bliebig vielen Rechnern gestartet werden.\\

\paragraph{Resultworker}
\begin{lstlisting}[style=BashInputStyle]
 # docker run murthy10/osm-crosswalk-detection REDIS_IP_ADDR 
 --role resultworker
\end{lstlisting}
Die Resultate werden im File crosswalks.json gespeichert, dieses findet man im Verzeichnis in dem der Resultworker gestartet wurde.
\newpage
\subsection{Keras Training}
Für das Training des Neuronalen Netzes steht ein eigenes Docker Image\footnote{\url{https://hub.docker.com/r/sebu/keras_cuda/}} auf Docker Hub bereit. Das Image basiert auf einem offiziellen Nvidia Cuda und ist fähig mit einer Nvidia Grafikkarte zur arbeiten. Die Grafikkarte wird mithilfe des nvidia-docker\footnote{\url{https://github.com/NVIDIA/nvidia-docker}} Projekts geladen. CUDA muss dabei auf dem Host Rechner installiert sein.


\paragraph{Start Keras Image}
\begin{lstlisting}[style=BashInputStyle]
# Download des nvidia-docker Projekts
git clone https://github.com/NVIDIA/nvidia-docker.git
cd nvidia-docker

# Herunterladen des Images
docker pull sebu/keras_cuda
# Start des Containers und mount der Grafikkarte #0
GPU=0 ./nvidia-docker run -i -t sebu/keras_cuda /bin/bash
\end{lstlisting}

Achtung: Die Keras Bibliothek entwickelt sich ständig weiter. Auch das Interface der populärsten Klassen können sich ändern und haben sich auch schon während diesem Projekt verändert! In diesem Keras Docker Image ist der Stand von Keras installiert, mit dem wir gearbeitet haben. Keras bietet leider keine Versionierung an. Der von uns verwendete Stand ist auch auf der mitglieferten CD erhältlich.

Ein Beispiel für das Training eines Neuronalen Netzes kann in examples/ConvnetTrainer.py und in den Keras eigenen Examples eingesehen werden.
\newpage
\subsection{Challenge erstellen}
Nach dem die Fussgängerstreifen detektiert wurden und das File crosswalks.json erstellt wurde, muss dies noch in ein passendes Format für MapRoulette gebracht werden. Dazu haben wir ein Python Skript geschrieben, welches aus jedem gefundenen Fussgängerstreifen einen Task generiert.

\subsubsection{Anwendung}
Für eine Challenge benötigt es ein File challange.json, welches die Challenge beschreibt und ein zweites File tasks.json in dem sich die Tasks befinden.\\

\paragraph{Tasks generieren}
\begin{lstlisting}[style=BashInputStyle]
 # python TaskGenerator.py crosswalks.json
\end{lstlisting}

\paragraph{Challenge publizieren}
\begin{lstlisting}[style=BashInputStyle]
 # curl -u devuser:mylittlesony -vX 
   POST http://maproulette.org/api/admin/challenge/
   crosswalk-detection/tasks -d @tasks.json 
   --header "Content-Type: application:json"
\end{lstlisting}

\paragraph{Tasks publizieren}
\begin{lstlisting}[style=BashInputStyle]
 # curl -u devuser:mylittlesony -vX 
   POST http://maproulette.org/api/admin/challenge/
   crosswalk-detection -d @challenge.json 
   --header "Content-Type: application:json"
\end{lstlisting}


Als Hilfestellung zum erstellen von MapRoulette Challanges ist folgendes Tutorial zu empfehlen:
\begin{itemize}
	\item \url{https://gist.github.com/mvexel/b5ad1cb0c91ac245ea3f}
\end{itemize}