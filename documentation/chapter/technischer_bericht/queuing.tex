\section{Parallelisierung}
Zu Beginn unserer Arbeit unterschätzten wir die enorme Datenmenge in Form von Orthofotos (Beispiel Schweiz: 7.1 Millionen Bilder à $5820 m^{2}$ Fläche pro Bild). Weiter wird auch sehr viel Rechenleistung für die Erkennung der Fussgängerstreifen auf den Bilder benötigt. Um diesen nicht trivialen Problemen herr zu werden, setzten wir auf eine Parallelisierungsstratege mit Hilfe einer Queue.

\begin{tabbing}
    \hspace*{3cm}\=\hspace*{6cm}\= \kill
	Queue: \> Redis\footnote{\url{http://redis.io/}} \\
	Python Library: \> RQ\footnote{\url{http://python-rq.org/}} \\
\end{tabbing}

\decision{Queueing Sytem}
Den Entscheid für Redis in Kombination mit RQ haben wir während eines Meeting mit Hilfe von Mitarbeitern des Institut für Software erarbeitet. RQ ist eine relativ einfach zu verwendende Library, welche Redis (Key Value Store) als Queue einsetzt. Durch die Einfachheit und die gute Integration in Python haben wir uns für diesen Lösungsweg entschieden.

\subsection{Ablauf}
\begin{figure}[H]
\includegraphics[width=\textwidth]{images/queuing.png}
\caption[Queueing]{Queueing}
\end{figure}
Auf der Abbildung ist zu sehen, dass wir für die verarbeiten der Jobs auf zwei Queues setzten, eine die die Abzuarbeitenden Bounding Boxes beinhält und eine weitere für das Sammeln der Resultate. Der genau Ablauf gestallte sich wie folgt:
\begin{enumerate}
		\item Manager wird aufgerufen mit Grosser Bounding Box
		\item Manager teilt Bounding Box auf
		\item Kleine Bounding Boxes werden als Job in die Job Queue geladen
		\item Jobs werden von den Worker aus der Queue geholt
		\item Worker arbeiten kleine Bounding Boxen ab
		\item Worker stellt die gefunden Punkt in Result Queue
		\item Result Worker holt die gefunden Punkt aus der Result Queue und speichert diese in einem JSON File 
\end{enumerate}









